package wanderingdevelopment.tk.chatsdkcore.db;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.sqlite.SQLiteDatabase;

import org.greenrobot.greendao.AbstractDao;
import org.greenrobot.greendao.AbstractDaoSession;
import org.greenrobot.greendao.Property;
import org.greenrobot.greendao.annotation.Entity;
import org.greenrobot.greendao.async.AsyncSession;
import org.greenrobot.greendao.database.Database;
import org.greenrobot.greendao.query.QueryBuilder;
import org.greenrobot.greendao.query.WhereCondition;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import java.util.Random;

import co.chatsdk.core.entities.Message;
import co.chatsdk.core.entities.Thread;
import co.chatsdk.core.interfaces.StorageAdapter;
import timber.log.Timber;
import wanderingdevelopment.tk.chatsdkcore.BuildConfig;
import wanderingdevelopment.tk.chatsdkcore.entities.AuthCredential;
import wanderingdevelopment.tk.chatsdkcore.entities.User;

/**
 * Created by kykrueger on 2016-11-21.
 */

public class DaoCore {

    private static String daoDbName = null;
    private static DaoCore daoCore = null;
    private static DaoSession daoSession;
    private static AsyncSession asyncSession;
    public static String PREFERENCES_STRING_ACCESS = "AUTH_PREFERENCES";
    public static String PREFERENCE_KEY_DATABASE_ID = "PREFERENCE_KEY_DATABASE_ID";
    public static String PREFERENCE_VALUE_DEFAULT_EMPTY= "INITIAL_DB";

    public static final int ORDER_ASC = 0;
    public static final int ORDER_DESC = 1;


    /** The property of the "EntityID" of the saved object. This entity comes from the server, For example Firebase server save Entities id's with an Char and Integers sequence.
     * The link between Entities in the databse structure is based on a long id generated by the database automatically.
     * To obtain an Entity using his server id we have to user this property.
     * Each Entity generates its own EntityID property so its very important to save the property id as the first property right after the long id property.
     * A workaround this is available by Checking for certain classes and use a different property for this class.*/
    public final static Property EntityID = new Property(1, String.class, "entityID", false, "ENTITY_ID");



    private DaoCore(Context ctx, String dbName){
        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(ctx, dbName, null);
        SQLiteDatabase db = helper.getWritableDatabase();
        DaoMaster daoMaster = new DaoMaster(db);
        daoSession = daoMaster.newSession();
        asyncSession = daoSession.startAsyncSession();
        daoDbName = dbName;
    }

    public static DaoCore resetDaoCore(Context applicationContext){
        return getDaoCore(applicationContext, PREFERENCE_VALUE_DEFAULT_EMPTY);
    }

    public static DaoCore getDaoCore(Context applicationContext, String dbName) {

        AuthCredential authCredential = null;

        // Backup credentials if changing DB
        if(daoDbName != null && daoDbName.equals(dbName)){
            authCredential = daoCore.fetchEntityWithProperty(AuthCredential.class,
                    AuthCredentialDao.Properties.UserAlias, dbName
            );

            daoCore = null;
        }

        if(daoCore == null){
            daoCore = new DaoCore(applicationContext, dbName);
        }

        // Save backup credentials in new DB
        if(authCredential != null) {
            daoCore.createOrReplace(authCredential);
        }
        return daoCore;
    }

    public static DaoCore getDaoCore(Context context){
        String daoDatabaseId;

        daoDatabaseId = getSharedPreferences(context).getString(DaoCore.PREFERENCE_KEY_DATABASE_ID,
                DaoCore.PREFERENCE_VALUE_DEFAULT_EMPTY);
        return getDaoCore(context, daoDatabaseId);
    }

    public static SharedPreferences getSharedPreferences(Context ctx){
        return ctx.getApplicationContext()
                .getSharedPreferences(DaoCore.PREFERENCES_STRING_ACCESS, Context.MODE_PRIVATE);
    }

    public String generateEntity() {
        return new BigInteger(130, new Random()).toString(32);
    }


//    /** Fetch entity for fiven entity ID, If more then one found the first will be returned.*/
//    public <T extends Object> T fetchEntityWithEntityID(Class<T> c, Object entityID){
//        return fetchEntityWithProperty(c, EntityID, entityID);
//    }
    public User fetchCurrentUser(){
        Class<AuthCredential> c = AuthCredential.class;
        QueryBuilder<AuthCredential> qb = daoSession.queryBuilder(c);
        qb.list();

        List<AuthCredential> list = qb.list();
        if (list != null && list.size()>0) {
            AuthCredential authCredential = (AuthCredential) list.get(0);
            return authCredential.getCurrentUser();
        } else return null;
    }

    /** Fetch an entity for given property and value. If more then one found the first will be returned.*/
    public <T extends Object> T fetchEntityWithProperty(Class<T> c, Property property, Object value){
        QueryBuilder<T> qb = daoSession.queryBuilder(c);
        qb.where(property.eq(value));

        List<T> list = qb.list();
        if (list != null && list.size()>0)
            return list.get(0) ;
        else return null;
    }

    public <T extends Object> T fetchEntityWithProperties(Class<T> c, Property properties[],Object... values){
        List<T> list = fetchEntitiesWithPropertiesAndOrder(c, null, -1, properties, values);

        if (list == null || list.size() == 0)
            return null;

        return list.get(0);
    }

    /** Fetch all entities of a given class. **/
    public <T extends Object> List<T> fetchEntitiesOfClass(Class<T> c){
        QueryBuilder<T> qb = daoSession.queryBuilder(c);
        if(c.equals(UserDao.class)){ // Order alphabetically if users
            qb = qb.orderAsc(UserDao.Properties.Name);
        }
        return qb.list();
    }

    public <T extends Object> List<T> fetchEntitiesWithPropertyLike(Class<T> c, String key) {
        QueryBuilder<T> qb = daoSession.queryBuilder(c);
        try {
            Class<?> cls = Class.forName(c.getName().concat("Dao"));
            Constructor<?> ct = cls.getConstructor();
            AbstractDao abstractDao = (AbstractDao) ct.newInstance();

            List<WhereCondition> whereConditions = new ArrayList<>();

            for ( Property property : abstractDao.getProperties()){
                whereConditions.add(property.like("%" + key + "%"));
            }

            WhereCondition[] conditionsArray = new WhereCondition[whereConditions.size()];
            conditionsArray = whereConditions.toArray(conditionsArray);

            if(conditionsArray.length == 1){
                qb.where(conditionsArray[0]);
            } else if(conditionsArray.length == 2) {
                qb.where(conditionsArray[0], conditionsArray[1]);
            } else if(conditionsArray.length > 2) {
                qb.whereOr(conditionsArray[0],
                        conditionsArray[1],
                        Arrays.copyOfRange(conditionsArray, 2, conditionsArray.length));
            }
        } catch (Exception e){
            if(BuildConfig.DEBUG) e.printStackTrace();
            return new ArrayList<T>();
        }
        return qb.list();
    }

    /** Fetch a list of entities for a given property and value.*/
    public <T extends Object> List<T> fetchEntitiesWithProperty(Class<T> c, Property property, Object value){
        QueryBuilder<T> qb = daoSession.queryBuilder(c);
        qb.where(property.eq(value));
        return qb.list();
    }

    /** Fetch a list of entities for a given properties and values.*/
    public <T extends Object> List<T> fetchEntitiesWithProperties(Class<T> c, Property properties[], Object... values){
        return fetchEntitiesWithPropertiesAndOrder(c, null, -1, properties, values);
    }

    /** Fetch a list of entities for a given property and value. Entities are arrange by given order.*/
    public <T extends Object> List<T> fetchEntitiesWithPropertyAndOrder(Class<T> c, Property whereOrder, int order, Property property, Object value){
        return fetchEntitiesWithPropertiesAndOrder(c, whereOrder, order, new Property[]{property}, value);
    }

    public <T extends Object> List<T>  fetchEntitiesWithPropertiesAndOrder(Class<T> c, Property whereOrder, int order, Property properties[], Object... values){

        if (values == null || properties == null)
            throw new NullPointerException("You must have at least one value and one property");

        if (values.length != properties.length)
            throw new IllegalArgumentException("Values size should match properties size");

        QueryBuilder<T> qb = daoSession.queryBuilder(c);
        qb.where(properties[0].eq(values[0]));

        for (int i = 0 ; i < values.length ; i++)
            qb.where(properties[i].eq(values[i]));

        if (whereOrder != null && order != -1)
            switch (order)
            {
                case ORDER_ASC:
                    qb.orderAsc(whereOrder);
                    break;

                case ORDER_DESC:
                    qb.orderDesc(whereOrder);
                    break;
            }

        return qb.list();
    }

    public <T extends Object> List<T>  fetchEntitiesWithPropertiesAndOrderAndLimit(Class<T> c, int limit, Property whereOrder, int order, Property properties[], Object... values){

        if (values == null || properties == null)
            throw new NullPointerException("You must have at least one value and one property");

        if (values.length != properties.length)
            throw new IllegalArgumentException("Values size should match properties size");

        QueryBuilder<T> qb = daoSession.queryBuilder(c);
        qb.where(properties[0].eq(values[0]));

        if (values.length > 1)
            for (int i = 0 ; i < values.length ; i++)
                qb.where(properties[i].eq(values[i]));

        if (whereOrder != null && order != -1)
            switch (order)
            {
                case ORDER_ASC:
                    qb.orderAsc(whereOrder);
                    break;

                case ORDER_DESC:
                    qb.orderDesc(whereOrder);
                    break;
            }

        if (limit != -1)
            qb.limit(limit);

        return qb.listLazy();
    }
//
//    public <T extends Object> T fetchOrCreateEntityWithEntityID(Class<T> c, String entityId){
//        if (BuildConfig.DEBUG) Timber.v("fetchOrCreateEntityWithEntityID, EntityID: %s", entityId);
//
//        T entity = fetchEntityWithEntityID(c, entityId);
//
//        if (entity == null)
//        {
//            entity = getEntityForClass(c);
//
//            //entity.setEntityID(entityId);
//
//            entity = createEntity(entity);
//        }
//
//        return entity;
//    }

    /** Fetch an Entity for given property and class.
     * If no Entity found a new one will be created.
     * The calling method have to handle the the inserting
     * of the given value if a new Entity was created.
     *
     * @return and object that Extends the Entity object.
     * The object will be created from the given class.*/


    @SuppressWarnings("unchecked") private  <T extends Object> T fetchOrCreateEntityWithProperty(Class<T> c, Property property, Object value){
        if (BuildConfig.DEBUG) Timber.v("fetchOrCreateEntityWithProperty, Value: %s", value);
        T entity = fetchEntityWithProperty(c, property, value);

        if (entity != null)
            return entity;

        // Create the new entity.
        Class<T> clazz = null;
        T o = null;
        try {
            clazz = (Class<T>) Class.forName(c.getName());
            Constructor<T> ctor =  clazz.getConstructor(c);
            o = (T) ctor.newInstance();
        } catch (ClassNotFoundException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("ClassNotFoundException");
        } catch (NoSuchMethodException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("NoSuchMethodException");
        } catch (InvocationTargetException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("InvocationTargetException");
        } catch (InstantiationException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("InstantiationException");
        } catch (IllegalAccessException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("IllegalAccessException");
        }

        if (o != null)
        {
            return createEntity(o);
        }

        return null;
    }

    /* Update, Create and Delete*/
    public <T extends Object> T createEntity(T entity){
        if (BuildConfig.DEBUG) Timber.v("createEntity");

        if (entity == null)
        {
            return null;
        }

        asyncSession.insertOrReplace(entity);

        return entity;
    }

    public <T extends Object> T deleteEntity(T entity){
        if (BuildConfig.DEBUG) Timber.v("deleteEntity");

        if (entity == null)
        {
            if (BuildConfig.DEBUG) Timber.e("Entity is null");
            return null;
        }

        asyncSession.delete(entity);

        return entity;
    }

    public <T extends Object> T createOrReplace(T entity){

        if (entity==null)
            return null;

        asyncSession.insertOrReplace(entity);

        return entity;
    }

    @SuppressWarnings("unchecked") private <T extends Object> T getEntityForClass(Class<T> c){
        // Create the new entity.
        Class<T> clazz = null;
        T o = null;
        try {
            clazz = (Class<T>) Class.forName(c.getName());
            Constructor<T> ctor = clazz.getConstructor();
            o = ctor.newInstance();
        } catch (ClassNotFoundException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("ClassNotFoundException");
        } catch (NoSuchMethodException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("NoSuchMethodException");
        } catch (InvocationTargetException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("InvocationTargetException");
        } catch (InstantiationException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("InstantiationException");
        } catch (IllegalAccessException e) {
//                e.printStackTrace();
            if (BuildConfig.DEBUG) Timber.e("IllegalAccessException");
        }

        return o;
    }

}
